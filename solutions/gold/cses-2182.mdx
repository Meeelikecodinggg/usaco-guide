---
id: cses-2182
source: CSES
title: Divisor Analysis
author: Andi Qu
---

**Time Complexity:** $\mathcal O(N \log(\max(k_i)))$.

## Number of divisors

Each divisor of the number can be written as $\prod_{i = 1}^N x_i^{\alpha_i}$
where $0 \leq \alpha_i \leq k_i$.

Since there are $k_i + 1$ choices for $\alpha_i$, the number of divisors is
simply $\prod_{i = 1}^N (k_i + 1)$.

We can calculate this by iterating through the prime factors in $\mathcal O(N)$
time.

## Sum of divisors

Let the sum of divisors when only considering the first $i$ prime factors be
$S_i$. The answer will be $S_N$.

$$
\begin{aligned}
S_i &= S_{i - 1} \sum_{j = 0}^{k_i} x_i^j\\
    &= S_{i - 1} \cdot \frac{x_i^{k_i + 1} - 1}{x_i - 1}\\
\end{aligned}
$$

We can calculate each $S_i$ using fast exponentiation and modular inverses in
$\mathcal O(N \log(\max(k_i)))$ time.

## Product of divisors

Let the product and number of divisors when only considering the first $i$ prime
factors be $P_i$ and $C_i$ respectively. The answer will be $P_N$.

$$
\begin{aligned}
P_i &= P_{i - 1}^{k_i + 1} \left(x_i^{k_i(k_i + 1)/2} \right)^{C_{i - 1}}
\end{aligned}
$$

Again, we can calculate each $P_i$ using fast exponentiation in
$\mathcal O(N \log(\max(k_i)))$ time, but there's a catch! It might be tempting
to use $C_{i - 1}$ from your previously-calculated values in part 1 of this
problem, but those values will yield wrong answers.

This is because $a^b \not \equiv a^{b \bmod p} \pmod{p}$ in general. However, by
Fermat's little theorem, $a^b \equiv a^{b \bmod (p - 1)} \pmod{p}$ for prime
$p$, so we can just store $C_i$ modulo $10^9 + 6$ to calculate $P_i$.

<Spoiler title="How do we get this recurrence?">

Clearly
$$P_1 = x_1^0x_1^1x_1^2\dots x_1^{k_1} = x_1^\frac{k_1(k_1+1)}{2}$$
since all $x_i$ are prime. Then for $P_2$, we have

$$
\begin{aligned}
P_2 = & x_1^1\times x_1^2\times x_1^3\times\dots\times x_1^{k_1} \\
\times & x_2 \times x_2x_1 \times x_2x_1^2\times\dots\times x_2x_1^{k_1} \\
\times & x_2^2 \times x_2^2x_1 \times x_2^2x_1^2\times\dots\times x_2^2x_1^{k_1} \\
\vdots & \\
\times & x_2^{k_2} \times x_2^{k_2}x_1 \times x_2^{k_2}x_1^2\times\dots\times x_2^{k_2}x_1^{k_1} \\
= & P_1 \\
\times & P_1x_2^{k_1+1} \\
\times & P_1\left(x_2^{k_1+1}\right)^2 \\
\vdots & \\
\times & P_1\left(x_2^{k_1+1}\right)^{k_2} \\
= & P_1^{k_2+1}\left(x_2^{k_1+1}\right)^{k_2(k_2+1)/2} \\
= & P_1^{k_2+1}\left(x_2^{k_2(k_2+1)/2}\right)^{k_1+1}\text{.}
\end{aligned}
$$

To find $P_3$, we multiply each term we separated (each one we multiplied by $x_2^j$) by $x_3^j$.
It is not hard to see that we will multiply $k_3+1$ copies of $P_3$, since $j$ goes from 0 to $k_3$.
It is also not hard to see that we will multiply $x_3^j$ $(k_1+1)(k_2+1)$ times for all $j$, and that summing all $j$ will still be $k_3(k_3+1)/2$. Therefore we get

$$
P_3 = P_2^{k_3+1}\left(x_3^{(k_1+1)(k_2+1)}\right)^{k_3(k_3+1)/2}
$$

In general, to compute $P_i$, we will multiply $k_i+1$ copies of $P_{i-1}$.
Notice that increasing $i$ increases the number of $x_i$ we multiply by a factor of $k_3+1$ (visualize adding a "dimension" to the "grid" we created for $P_2$).
That is, the exponent of $x_i$ is $\prod_{j=1}^{i-1}(k_j+1)$, which is $C_{i-1}$
Switching the exponents, we arrive at the desired relation of

$$
P_i = P_{i-1}^{k_i+1}\left(x_i^{k_i(k_i+1)/2}\right)^{C_{i-1}}
$$

</Spoiler>

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

const ll MOD = 1e9 + 7;

ll expo(ll base, ll pow) {
	ll ans = 1;
	while (pow) {
		if (pow & 1) ans = ans * base % MOD;
		base = base * base % MOD;
		pow >>= 1;
	}
	return ans;
}

ll p[100001], k[100001];

int main() {
	cin.tie(0)->sync_with_stdio(0);
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) cin >> p[i] >> k[i];
	ll div_cnt = 1, div_sum = 1, div_prod = 1, div_cnt2 = 1;
	for (int i = 0; i < n; i++) {
		div_cnt = div_cnt * (k[i] + 1) % MOD;
		div_sum =
		    div_sum * (expo(p[i], k[i] + 1) - 1) % MOD * expo(p[i] - 1, MOD - 2) % MOD;
		div_prod = expo(div_prod, k[i] + 1) *
		           expo(expo(p[i], (k[i] * (k[i] + 1) / 2)), div_cnt2) % MOD;
		div_cnt2 = div_cnt2 * (k[i] + 1) % (MOD - 1);
	}
	cout << div_cnt << ' ' << div_sum << ' ' << div_prod;
	return 0;
}
```

</CPPSection>

</LanguageSection>
